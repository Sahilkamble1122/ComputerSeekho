{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 6, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":"","debugId":null}},
    {"offset": {"line": 66, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/sahil/OneDrive/Pictures/Documents/GitHub/ComputerSeekho_Frontend/Frontend/Next.Js_repo/computer_sekho/app/api/albums/route.js"],"sourcesContent":["import { NextResponse } from 'next/server';\r\n\r\nexport async function GET(request) {\r\n  try {\r\n    const { searchParams } = new URL(request.url);\r\n    const page = searchParams.get('page') || '1';\r\n    const limit = searchParams.get('limit') || '8';\r\n\r\n    // Fetch albums from Spring Boot backend\r\n    const albumsResponse = await fetch(`http://localhost:8080/api/albums?page=${page}&limit=${limit}`);\r\n    \r\n    if (!albumsResponse.ok) {\r\n      throw new Error(`Backend error: ${albumsResponse.status}`);\r\n    }\r\n\r\n    const albums = await albumsResponse.json();\r\n\r\n    // Fetch all images to get cover images\r\n    let allImages = [];\r\n    try {\r\n      const imagesResponse = await fetch('http://localhost:8080/api/images');\r\n      \r\n      if (imagesResponse.ok) {\r\n        allImages = await imagesResponse.json();\r\n        console.log('Fetched images from backend:', allImages.length, 'images');\r\n      } else {\r\n        console.warn(`Images backend error: ${imagesResponse.status}, proceeding without cover images`);\r\n      }\r\n    } catch (error) {\r\n      console.warn('Failed to fetch images, proceeding without cover images:', error.message);\r\n    }\r\n\r\n    // Enhance albums with cover images\r\n    const albumsWithCovers = albums.map(album => {\r\n      // Find the cover image for this album\r\n      const coverImage = allImages.find(img => {\r\n        // Handle both string and number types for albumId\r\n        const imgAlbumId = typeof img.albumId === 'string' ? parseInt(img.albumId) : img.albumId;\r\n        const albumId = typeof album.albumId === 'string' ? parseInt(album.albumId) : album.albumId;\r\n        \r\n        return imgAlbumId === albumId && img.isAlbumCover === true;\r\n      });\r\n\r\n      console.log(`Album ${album.albumId} (${album.albumName}):`, {\r\n        hasCoverImage: !!coverImage,\r\n        coverImageData: coverImage,\r\n        allImagesForAlbum: allImages.filter(img => {\r\n          const imgAlbumId = typeof img.albumId === 'string' ? parseInt(img.albumId) : img.albumId;\r\n          const albumId = typeof album.albumId === 'string' ? parseInt(album.albumId) : album.albumId;\r\n          return imgAlbumId === albumId;\r\n        })\r\n      });\r\n\r\n      // Construct the cover image URL properly\r\n      let coverImageUrl = null;\r\n      if (coverImage) {\r\n        if (coverImage.imagePath) {\r\n          // Handle both full paths and just filenames\r\n          if (coverImage.imagePath.startsWith('images/')) {\r\n            coverImageUrl = `/${coverImage.imagePath}`;\r\n          } else if (coverImage.imagePath.includes('/')) {\r\n            coverImageUrl = `/images/${coverImage.imagePath.split('/').pop()}`;\r\n          } else {\r\n            coverImageUrl = `/images/${coverImage.imagePath}`;\r\n          }\r\n          console.log(`Constructed cover URL for album ${album.albumId}:`, coverImageUrl);\r\n        }\r\n      } else {\r\n        // Fallback: use the first image from the album if no cover image is set\r\n        const firstImage = allImages.find(img => {\r\n          const imgAlbumId = typeof img.albumId === 'string' ? parseInt(img.albumId) : img.albumId;\r\n          const albumId = typeof album.albumId === 'string' ? parseInt(album.albumId) : album.albumId;\r\n          return imgAlbumId === albumId;\r\n        });\r\n        \r\n        if (firstImage && firstImage.imagePath) {\r\n          if (firstImage.imagePath.startsWith('images/')) {\r\n            coverImageUrl = `/${firstImage.imagePath}`;\r\n          } else if (firstImage.imagePath.includes('/')) {\r\n            coverImageUrl = `/images/${firstImage.imagePath.split('/').pop()}`;\r\n          } else {\r\n            coverImageUrl = `/images/${firstImage.imagePath}`;\r\n          }\r\n          console.log(`Using fallback image for album ${album.albumId}:`, coverImageUrl);\r\n        }\r\n      }\r\n\r\n      return {\r\n        ...album,\r\n        coverImage: coverImageUrl\r\n      };\r\n    });\r\n\r\n    return NextResponse.json(albumsWithCovers);\r\n\r\n  } catch (error) {\r\n    console.error('Error in GET /api/albums:', error);\r\n    return NextResponse.json(\r\n      { \r\n        error: 'Failed to fetch albums with cover images',\r\n        details: error.message\r\n      },\r\n      { status: 500 }\r\n    );\r\n  }\r\n}\r\n"],"names":[],"mappings":"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","debugId":null}}]
}